1. 자바
- 객체지향 프로그래밍 언어이며 큰 특징 중 하나가 운영체제에 독립적
- OS 위에 JVM이라는 가상머신 위에서 실행되기 때문

2. OOP
- 객체지향 프로그래밍(Object Oriented Programming)
- 현실 세계의 사물을 객체라 생각하고 객체들의 상호작용을 통해 작동
- 객체 지향적 설계 원칙
    1. SRP(Single Responsibility Principle) : 단일 책임 원칙
        - 클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유여야 한다
    2. OCP(Open-Closed Principle) : 개방-폐쇄 원칙
        - 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다
    3. LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
        - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 작동해야 한다
    4. ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
        - 클라이언트는 사용하지 않는 인터페이스에 의존해서는 안된다
    5. DIP(Dependency Inversion Priciple) : 의존 역전 원칙
        - 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다


3. 객체
- 소프트웨어 세계에서 구현할 대상
- 클래스의 타입으로 선언되었을 때

4. 클래스
- 객체를 만들어내기 위한 설계도
- 연관되어 있는 필드와 메소드의 집합

5. 인스턴스
- 객체가 구현된 구체적인 실체        
- 객체가 메모리에 할당되어 사용될 때

6. 캡슐화
- 객체의 필드와 메소드를 하나로 묶고 구현 내용을 감추는 것
- 객체가 필요한 변수나 메소드를 하나로 묶는 것을 의미
- 접근제한자를 통해 외부로 노출
- private - default - protected(다른 패키지 상속까지 허용) - public
- 정보은닉 -> 캡슐화가 되어 있다고 반드시 정보은닉이 되는건 아니다

7. 상속
- 기존 클래스를 확장하는 개념
- 재사용함으로 코드의 중복을 줄이고 검증된 로직을 제외하고 개발에 신경 쓸 수있다

8. 다형성
- 하나의 객체가 여러 가지 타입을 가질 수 있는 것을 의미
- Overriding : 클래스를 재정의
- Overloading : 이름이 같은 여러개의 메소드 정의. 파라미터, 리턴 타입이 다름

9. 추상화
- 복잡한 문제를 다루기 위해 불필요한 부분을 숨기고 중요한 부분만 표현하는 것
- 공통된 필드와 메소드를 모으는 것

10. Garbage Colector(GC)
- '정리되지 않은 메모리', '유효하지 않은 메모리 주소'
- GC의 과정을 Mark and Sweep이라 한다
    - reachable 객체를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾는 과정이 Mark
    - 이 과정에서 Stop the world 발생. 이후, Mark 되어있지 않은 객체들을 heap에서 제거하는 과정이 Sweep

11. Stack vs Heap
- Stack
    - 지역 변수와 함수 호출시 사용된 변수를 저장
    - 각 스레드마다 stack 영역을 갖고 있다, 즉 개별적인 메모리
    - 함수 호출이나 지역 변수를 저장하다가 stack에 저정할 공간이 없을 경우, JVM은 StackOverFlowError 발생
- Heap
    - 자바 객체를 저장하기 위해 사용
    - 객체를 생성하다가 heap에 저장할 공간이 없을 경우 OutOfMemoryError를 발생
    - 모든 스레드가 공유하는 메모리

12. Tree(트리)
- 노드로 이루어진 자료구조

13. 트랜잭션
- 하나의 논리적 기능을 수행하기 위한 작업 단위
- 하나의 트랜잭션은 commit 되거나 rollback 된다
- ACID
    - Atomicity(원자성)
        - 모든 명령은 반드시 완벽하게 수행되어야 하며, 하나라도 오류가 발생하면 전부 취소가 되어야한다
    - Consistency(일관성)
        - 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다
    - Isolation(독립성)
        - 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다
    - Durablility(영속성)
        - 완료된 트랜잭션의 결과는 영구적으로 반영되어야 한다
- 격리 수준
    - Read Uncommitted
        - commit이나 rollback 상관없이 다른 트랜잭션에게 보여진다
        - Dirty Read 발생
    - Read Committed(Oracle)
        - 어떤 트랜잭션의 변경 내용이 commit이 되어야만 다른 트랜잭션에서 조회할 수 있다
        - non-repeatable 발생
    - Repeatable Read(Mysql)
        - 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회 가능
        - 자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 변경된(커밋된) 것만 보게 되는 것
        - update 부정합 발생
        - phantom read 발생(insert)
    - Serializable
        - 읽기 작업에도 공유 잠금이 설정되어 다른 트랜잭션에서 변경을 할 수 없다
        - 동시처리 능력이 다른 격리수준보다 떨어지고 성능저하가 발생한다